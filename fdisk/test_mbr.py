import unittest
import fdisk.mbr as mbr
import io

#
# Units: sectors of 1 * 512 = 512 bytes
# Sector size (logical/physical): 512 bytes / 512 bytes
# I/O size (minimum/optimal): 512 bytes / 512 bytes
# Disklabel type: dos
# Disk identifier: 0x2c660625
# Device     | Boot |  Start  |  End     | Sectors  |  Size  |  Id |  Type                |
# image.img1 | *    |  2048   |   616447 |   614400 |   300M |  c  |  W95 FAT32 (LBA)     |
# image.img2 |      |  616448 |  7774207 |  7157760 |   3.4G |  83 |  Linux               |
# Partition 1
#     Start-C/H/S: 0/33/3
#       End-C/H/S: 80/102/44
# Partition 2
# Start-C/H/S: 80/102/45
#  End-C/H/S: 1019/53/28
#
valid_mbr = [
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x06, 0x66, 0x2c, 0x00, 0x00, 0x80, 0x21,
    0x03, 0x00, 0x0c, 0x66, 0x2c, 0x50, 0x00, 0x08, 0x00, 0x00, 0x00, 0x60, 0x09, 0x00, 0x00, 0x66,
    0x2d, 0x50, 0x83, 0x35, 0xdc, 0xfb, 0x00, 0x68, 0x09, 0x00, 0x00, 0x38, 0x6d, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xaa
]

invalid_mbr = valid_mbr[:-2] + [0, 0]


class CHSTestCase(unittest.TestCase):
    def test_should_parse_valid_chs_address(self):
        chs_address = mbr.CHSAddress.parse(b'!\x03\x00')
        self.assertEqual(3, chs_address.sector)
        self.assertEqual(33, chs_address.head)
        self.assertEqual(0, chs_address.cylinder)

    def test_should_build_valid_chs(self):
        chs_address = mbr.CHSAddress(0, 33, 3)
        self.assertEqual(bytes(chs_address), b'!\x03\x00')

    def test_should_not_build_invalid_chs(self):
        chs_address = mbr.CHSAddress(5000, 33, 3)
        self.assertRaises(AssertionError, lambda: bytes(chs_address))


class PartitionTestCase(unittest.TestCase):
    def test_should_read_partition(self):
        partition = mbr.PartitionEntry.read(bytes([128, 33, 3, 0, 12, 102, 44, 80, 0, 8, 0, 0, 0, 96, 9, 0]))
        self.assertEqual(mbr.PartitionId.WIN95_FAT32_LBA, partition.partition_type)
        self.assertEqual(2048, partition.start_block_address.sector)
        self.assertEqual(616447, partition.end_block_address.sector)
        self.assertEqual(614400, partition.sector_count)
        self.assertEqual(614400 * 512, partition.byte_count)
        self.assertEqual(mbr.CHSAddress(0, 33, 3), partition.start_chs)
        self.assertEqual(mbr.CHSAddress(80, 102, 44), partition.end_chs)

    def test_should_write_valid_partition(self):
        expected = bytes([128, 33, 3, 0, 12, 102, 44, 80, 0, 8, 0, 0, 0, 96, 9, 0])
        partition = mbr.PartitionEntry.read(expected)
        self.assertEqual(expected, bytes(partition))


class MBRTestCase(unittest.TestCase):
    def test_should_parse_valid_mbr(self):
        value = mbr.MasterBootRecord.read(io.BytesIO(bytes(valid_mbr)))
        self.assertIsNotNone(value)
        self.assertEqual(0x2c660625, value.unique_id)

    def test_should_not_parse_invalid_mbr(self):
        value = mbr.MasterBootRecord.read(io.BytesIO(bytes(invalid_mbr)))
        self.assertIsNone(value)

    def test_should_parse_partition_table(self):
        value = mbr.MasterBootRecord.read(io.BytesIO(bytes(valid_mbr)))
        self.assertIsNotNone(value)
        # two partitions
        partitions = [v for v in value.partitions if v.partition_type != mbr.PartitionId.EMPTY]
        self.assertEqual(len(partitions), 2)
        # two empty
        self.assertEqual(len([v for v in value.partitions if v.partition_type == mbr.PartitionId.EMPTY]), 2)
        # first is bootable win95 fat32
        self.assertEqual(mbr.PartitionId.WIN95_FAT32_LBA, partitions[0].partition_type)
        self.assertTrue(partitions[0].bootable)
        # second is linux non-bootable
        self.assertEqual(mbr.PartitionId.LINUX, partitions[1].partition_type)
        self.assertFalse(partitions[1].bootable)

    def test_should_parse_partition_lba_sizes(self):
        value = mbr.MasterBootRecord.read(io.BytesIO(bytes(valid_mbr)))
        self.assertIsNotNone(value)
        # two partitions
        partitions = [v for v in value.partitions if v.partition_type != mbr.PartitionId.EMPTY]

        # partition 1
        self.assertEqual(2048, partitions[0].start_block_address.sector)
        self.assertEqual(616447, partitions[0].end_block_address.sector)
        self.assertEqual(614400, partitions[0].sector_count)
        self.assertEqual(614400 * 512, partitions[0].byte_count)

        # partition 2
        self.assertEqual(616448, partitions[1].start_block_address.sector)
        self.assertEqual(7774207, partitions[1].end_block_address.sector)
        self.assertEqual(7157760, partitions[1].sector_count)
        self.assertEqual(7157760 * 512, partitions[1].byte_count)

    def test_should_parse_partition_chs_sizes(self):
        value = mbr.MasterBootRecord.read(io.BytesIO(bytes(valid_mbr)))
        self.assertIsNotNone(value)
        # two partitions
        partitions = [v for v in value.partitions if v.partition_type != mbr.PartitionId.EMPTY]

        # partition 1
        self.assertEqual(mbr.CHSAddress(0, 33, 3), partitions[0].start_chs)
        self.assertEqual(mbr.CHSAddress(80, 102, 44), partitions[0].end_chs)

        # partition 2
        self.assertEqual(mbr.CHSAddress(80, 102, 45), partitions[1].start_chs)
        self.assertEqual(mbr.CHSAddress(1019, 53, 28), partitions[1].end_chs)

    def test_should_write_parsed_mbr(self):
        value = mbr.MasterBootRecord.read(io.BytesIO(bytes(valid_mbr)))
        self.assertIsNotNone(value)
        self.assertEqual(bytes(valid_mbr), bytes(value))


if __name__ == '__main__':
    unittest.main()
